/* NOTE: This source code has been tested to compile with THINK C   3.02, but with some porting work, it can be used with other   compilers.  */#include <FileMgr.h>#include <DeviceMgr.h>#include <DiskDvr.h>#include <SerialDvr.h>#include <SCSIMgr.h>#include <stdio.h>/* Since old Lightspeed C does not define the extended drive queue   element structure, we define it ourselves here to guarantee   that we have it available.  */typedef	struct		{/*	long		flags;		*/	struct QElem *qLink; 	int			qType;	int			dQDrive;	int			dQRefNum;	int			dQFSID;	int			dQDrvSize;	int			dQDrvSz2;	} DrvQEl2,*DrvQEl2Ptr ;/* File Tags buffer global variables appear not to be defined   in the LightSpeed C headers.  */extern long BufTgFNum : 0x2fc;extern int BufTgFFlag : 0x300;extern int BufTgFBkNum : 0x302;extern long BufTgDate : 0x304;/* SCSI definitions *//* Commands */#define SC_INQUIRY 0x12#define SC_READ_CAPACITY_10 0x25#define SC_READ_10 0x28/* Statuses */#define SC_GOOD 0x00#define SC_CHECK_CONDITION 0x02#define SC_CONDITION_MET 0x04#define SC_BUSY 0x08#define SC_ACA_ACTIVE 0x30#define SC_TASK_ABORTED 0x40#define SC_VENDOR_ID_SIZE 8#define SC_PRODUCT_ID_SIZE 16#define SC_REVISION_SIZE 4#define SC_COMPLETION_TIMEOUT 300typedef struct  {	unsigned char DeviceType;	unsigned char DeviceQualifier;	unsigned char Version;	unsigned char ResponseFormat;	unsigned char AdditionalLength;	unsigned char VendorUse1;	int Reserved1;	char VendorID[SC_VENDOR_ID_SIZE];	char ProductID[SC_PRODUCT_ID_SIZE];	char Revision[SC_REVISION_SIZE];	unsigned char VendorUse2[20];	unsigned char Reserved2[42];	unsigned char VendorUse3[158];} MyInquiryRecord;typedef struct  {	unsigned long last_lba;	unsigned long blksize;} MyReadCapRecord;typedef struct  {	int scsi_id;	unsigned char cdb[16];	int cdb_len;	unsigned char *buffer;	unsigned int buffer_len;	int comp_status;	int comp_msg;	OSErr comp_err;} PBSc1;/* TODO: We should check the driver descriptor indices and see   if we are being shown a large hard disk.  We should also   ask the user if this size looks correct, and if not, they can   manually enter the correct number of blocks to read.   OS 6.0.7 versus OS 6.0.8 behave markedly differently,   surprisingly.  *//* TODO: If INQUIRE succeeds but READ CAPACITY fails, see if we can   get our desired information from the driver descriptor record at   block zero.  If so, we can carry on by using that.  *//* TODO: We should scan SCSI 0 through 6 for a response on   INQUIRE.  This is how we give the user selections on what   drives are available.  Then they can pick the one that looks   good.  *//* TODO: Beyond what looks like antiquated SCSI handling, we   better support both the old and the new versions, just in   case...  *//* TODO: We should also read out the contents stored in the driver   descriptor record and verify them with the information we've   retrieved from the SCSI disk commands.  We just want to be sure   we're getting the right stuff.  *//* TODO: We need a mode where we send disk metadata to the target   computer, and that we can write that out into a sidecar file.   Namely, (1) whether we exclusively copy 512-byte user data sectors,   include 12-byte file tags, or include 20 bytes of SCSI hard disk   Mac OS system data, (2) whether we copied a Mac OS volume or a   SCSI disk, (3) the device driver we copied from, (4) the reported   volume size versus user manual filled in volume size.  For   starters, just copy this as text, then the user saves the output.   Really it is about the hardware, the data we get from running   on real hardware that cannot be obtained from.  sprintf()   into a text buffer, then copy over the serial connection, last   step along hte way.   Also, we should provide an auto-detection library for popular   models of vintage hard disks.   * Hard Disk 20   * Hard Disk 20SC   * Internal Hard Disk 20SC   * Internal Hard Disk 40SC   When we autodetect, we ask the user to confirm, and if accepted,   then we can assure them they can relax with peace of mind that   a professional and precise disk image will be performed.  So long   as they're hardware is operating fine.   Oh, and prompting.  If your hard disk drive is making abnormal   sounds that it didn't use to make when it was younger in normal   operation, please shut down immediately and contact a professional   to make the disk image.  These are signs of impending hard disk   failure.*//* TODO: We must be able to handle non-512-byte blocks, up to a   maximum size of 532 bytes.  Larger than this, we detect and   flag an error.  *//* Buffer 4 blocks of 512 bytes, this is about as large as is   practical a buffer when transferring data at 28.8 kbits/sec.  *//* NOTE: We allocate 532 * 4 bytes because Hard Disk 20SC contains   532-byte sectors, the extra 20 bytes are for system use only.  */unsigned char g_buffer[532*4];/* N.B. We define these variables as global to avoid risks of stack   overflows.  */int sc_init = 0;int g_scsi_id;MyInquiryRecord iq_resp;MyReadCapRecord read_cap;Block0 ddr;/* Macintosh requires at least three partitions: (0) partition table,   (1) disk device driver, (2) Macintosh filesystem volume.  Plus we   have one more entry to catch the extra 20 bytes that come from the   532-byte size sectors from Hard Disk 20SC, so that a buffer   overflow does not corrupt unintended data.  */Partition pm[4];voidshowhex(ptr, size)unsigned char *ptr;unsigned long size;{	unsigned long i;	for (i = 0; i < size; i++)	{		if ((i & (8 - 1)) == 0)		{			printf("\n%08lx-", i);		}		printf(" %02x", (int)ptr[i]);	}	putchar('\n');}/* Execute a single SCSI read-style command, with proper bus arbitrate   and free.   N.B. Purportedly the reason for SCSIInstr magic is to provide for a   more optimized code path for reading multiple blocks, but we don't   need that additional speed since our serial communications is the   main speed bottleneck.  Also, SCSI READ allows for reading more   than one block at a time.   TODO: Evaluate/answer this question.  Is there a limit on the   number of SCSI blocks that can be read continuously in a single   SCSI command?  I imagine that could have been one of the   motivations for the SCSIInstr construct.  And that purportedly   older hardware would have a lower limit than newer hardware.   Hopefully reading 4 blocks at a time isn't too much for the oldest   of hardware.  */OSErrsc1read(pb)PBSc1 *pb;{	SCSIInstr tib[2];	OSErr err;	tib[0].scOpcode = scNoInc;	tib[0].scParam1 = (long)pb->buffer;	tib[0].scParam2 = pb->buffer_len;	tib[1].scOpcode = scStop;	tib[1].scParam1 = 0;	tib[1].scParam2 = 0;	err = SCSIGet();	if (err != noErr)	{		/* if (err == scCommErr)			puts("Communications erro, operation timeoutr.");		else if (err == scArbNBErr)			puts("Bus busy, arbitration timeout.");		else if (err == scMgrBusyErr)			puts("SCSI Manager busy error."); */		return err;	}	err = SCSISelect(pb->scsi_id);	if (err != noErr)	{		/* if (err == scCommErr)			puts("Communications error, operation timeout.");		else if (err == scArbNBErr)			puts("Bus busy, arbitration timeout.");		else if (err == scSequenceErr)			puts("Attempted operation is out of sequence."); */		/* N.B. Some Macintoshes will arbitrate the bus on		   `SCSIGet()', in which case we must call `SCSIComplete()' to		   free the bus.  */		goto cleanup;	}	err = SCSICmd((char*)pb->cdb, pb->cdb_len);	if (err != noErr)	{		/* if (err == scCommErr)			puts("Communications error, operation timeout.");		else if (err == scArbNBErr)			puts("Bus busy, arbitration timeout.");		else if (err == scPhaseErr)			puts("Phase error on the SCSI bus."); */		goto cleanup;	}	err = SCSIRead((char*)tib);	if (err != noErr)	{		/* if (err == scCommErr)			puts("Communications error, operation timeout.");		else if (err == scBadParamsErr)			puts("Unrecognized TIB instruction.");		else if (err == scPhaseErr)			puts("Phase error on the SCSI bus.");		else if (err == scCompareErr)			puts("Comparison error from scComp instruction."); */	}cleanup:	pb->comp_err = SCSIComplete(&pb->comp_status, &pb->comp_msg,		(unsigned long)SC_COMPLETION_TIMEOUT);	if (pb->comp_err != noErr)	{		/* if (err == scCommErr)			puts("Communications error, operation timeout.");		else if (err == scPhaseErr)			puts("Phase error on the SCSI bus.");		else if (err == scComplPhaseErr)			puts("SCSI bus was not in status phase on entry to SCSIComplete."); */	}	return err;}main(){	QHdrPtr the_head;	int td_pick = 0;	int td_dnum;	int td_dref;	unsigned long td_size = 0;	int soutref = 0;	the_head = &DrvQHdr;	puts("Started successfully.");	{		int pchar = 'n';		fputs("Show super simple code demo? (y/n) ",			  stdout);		pchar = getchar(); putchar('\n');		if (pchar == 'y')		{			char *mybytes = "Hello, okay this works fine.";			unsigned long sw_size = 4;			puts("Hello world!");			showhex(mybytes, sw_size);		}	}	{		DrvQEl2 *elem = (DrvQEl2*)(the_head->qHead);		unsigned char *dflags = ((unsigned char*)elem) - 4;		/* PLEASE NOTE: Drive queue sizes are in units of		   512-byte blocks.  */		while (elem)		{			if (elem->qType == drvQType)			{				int pchar = 'n';				puts("Classic drive queue header.");				printf("Drive %d, ref %d, FSID %d, DrvSize %d\n",					elem->dQDrive, elem->dQRefNum, elem->dQFSID,					elem->dQDrvSize);				fputs("Pick? (y/n) ", stdout);				pchar = getchar(); putchar('\n');				if (pchar == 'y' && !td_pick)				{					td_pick = 1;					td_dnum = elem->dQDrive;					td_dref = elem->dQRefNum;					td_size = 1600;				}			}			else if (elem->qType == 0)			{				int pchar = 'n';				puts("Small disk drive queue header.");				printf("Drive %d, ref %d, FSID %d, DrvSize %d\n",					elem->dQDrive, elem->dQRefNum, elem->dQFSID,					elem->dQDrvSize);				fputs("Pick? (y/n) ", stdout);				pchar = getchar(); putchar('\n');				if (pchar == 'y' && !td_pick)				{					td_pick = 1;					td_dnum = elem->dQDrive;					td_dref = elem->dQRefNum;					td_size = 1600;				}			}			else if (elem->qType == 1)			{				int pchar = 'n';				unsigned long full_size =					(unsigned long)elem->dQDrvSize |					((unsigned long)elem->dQDrvSz2 << 16);				puts("Large disk drive queue header.");				printf("Drive %d, ref %d, FSID %d, DrvSize %lu\n",					elem->dQDrive, elem->dQRefNum, elem->dQFSID,					full_size);				fputs("Pick? (y/n) ", stdout);				pchar = getchar(); putchar('\n');				if (pchar == 'y' && !td_pick)				{					td_pick = 1;					td_dnum = elem->dQDrive;					td_dref = elem->dQRefNum;					td_size = full_size;				}			}			else			{				printf("Unexpected type %d!\n", elem->qType);				printf("Drive %d, ref %d, FSID %d, DrvSize %d\n",					elem->dQDrive, elem->dQRefNum, elem->dQFSID,					elem->dQDrvSize);			}			if ((dflags[0] & 0x80) == 0x80)				puts("Volume locked.");			else				puts("Volume unlocked.");			if (dflags[1] == 0)				puts("No disk in drive.");			else if (dflags[1] == 1 || dflags[1] == 2)				puts("Disk in drive.");			else if (dflags[1] == 8)				puts("Non-ejectable disk.");			else if (dflags[1] >= 0xfc && dflags[1] <= 0xff)				puts("Disk was ejected within last 1.5 seconds.");			else if (dflags[1] == 0x48)				puts("Non-ejectable but driver wants eject call.");			else				printf("dflags[1] == %d\n", (int)dflags[1]);			if ((dflags[3] & 0x80) == 0)			{				puts("Single-sided disk.");				if (td_size == 1600)					td_size = 400;			}			else				puts("Double-sided disk or not applicable.");			elem = (DrvQEl2*)elem->qLink;		}	}	/* Hooray!  So far, so good.  So now we can test reading	   one disk block from the first drive and listing its	   hex bytes to standard output.  */	if (td_pick && td_size > 0)	{		OSErr err;		IOParam pb;		pb.ioVRefNum = td_dnum;		pb.ioRefNum = td_dref;		pb.ioBuffer = (char*)g_buffer;		pb.ioReqCount = 512;		pb.ioPosMode = fsFromStart;		pb.ioPosOffset = 0;		err = PBRead(&pb, false);		if (err == noErr)		{			int pchar = 'n';			unsigned long res_size = pb.ioActCount;			printf("Great read, %ld bytes.\n", pb.ioActCount);			fputs("Show hex dump? (y/n) ", stdout);			pchar = getchar(); putchar('\n');			if (pchar == 'y')				showhex((char*)g_buffer, res_size);		}		else if (err == badUnitErr)			puts("Bad unit error.");		else if (err == notOpenErr)			puts("Drive isn't open error.");		else if (err == unitEmptyErr)			puts("Bad reference number error.");		else if (err == readErr)			puts("Read error.");		else			puts("Unknown error.");	}	/* Hooray!!  Life is good, life is great.  So now we step up	   to the next level and try writing out some data to the	   serial communications port.  Why not loop through it all	   and do everything?  */	if (td_pick && td_size > 0)	{		int pchar = 'n';		int do_next = 0;		OSErr err;		IOParam pb;		CntrlParam cpb;		SerStaRec *ssr;		/* Open the ROM serial driver output.  */		pb.ioNamePtr = (StringPtr)"\p.AOut";		pb.ioPermssn = fsWrPerm; /* fsRdPerm fsRdWrPerm */		err = PBOpen(&pb, false);		if (err == noErr)		{			soutref = pb.ioRefNum;			printf("Opened ROM serial driver %d okay!\n", soutref);			do_next = 1;		}		else if (err == badUnitErr)			puts("Bad reference number error.");		else if (err == dInstErr)			puts("Couldn't find driver error.");		else if (err == openErr)			puts("Can't perform requested read/write error.");		else if (err == unitEmptyErr)			puts("Bad reference number error.");		else			puts("Unknown error.");		/* Open the RAM serial driver for output.  */		/* err = RAMSDOpen(sPortA);		if (err == noErr)		{			soutref = -7;			printf("Opened RAM serial driver %d okay!\n", soutref);			do_next = 1;		}		else if (err == openErr)			puts("Can't open driver error.");		else			puts("Unknown error."); */		/* SerReset(): */		/* 19.2 kbits/sec baud, 8 data bits, 1 stop bit, no parity.  */		cpb.ioVRefNum = 0;		cpb.ioRefNum = soutref;		cpb.csCode = 8;		fputs("57.6 kbits/sec baud? (y/n) ", stdout);		pchar = getchar(); putchar('\n');		if (pchar == 'y')		{			puts("Using 57.6 kbits/sec baud.");			cpb.csParam[0] = (int)baud57600 | data8 | stop10 | noParity;		}		else		{			puts("Using 19.2 kbits/sec baud.");			cpb.csParam[0] = (int)baud19200 | data8 | stop10 | noParity;		}		if (do_next)		{			do_next = 0;			err = PBControl(&cpb, false);		}		if (err == noErr)		{			puts("Reset serial driver okay!");			do_next = 1;		}		else if (err == badUnitErr)			puts("Bad reference number error.");		else if (err == notOpenErr)			puts("Not open error.");		else if (err == unitEmptyErr)			puts("Bad reference number error.");		else if (err == controlErr)			puts("Control error.");		else			puts("Unknown error.");		/* SerHShake() */		/* Hardware flow control left on as is default for ROM		   serial driver.  */		/* TESTING: Disable handshake.  */		cpb.ioVRefNum = 0;		cpb.ioRefNum = soutref;		cpb.csCode = 10;		fputs("Hardware CTS handshake? (y/n) ", stdout);		pchar = getchar(); putchar('\n');		if (pchar == 'y')		{			puts("Using hardware CTS handshake.");			cpb.csParam[0] = 0x00ff; /* fXOn, fCTS */		}		else		{			puts("Using no handshake.");			cpb.csParam[0] = 0x0000; /* fXOn, fCTS */		}		cpb.csParam[1] = 0x0000; /* xOn, xOff */		cpb.csParam[2] = 0x0000; /* errs, evts */		cpb.csParam[3] = 0x0000; /* fInX, null */		cpb.csParam[4] = 0; /* safety */		cpb.csParam[5] = 0; /* safety */		cpb.csParam[6] = 0; /* safety */		if (do_next)		{			do_next = 0;			err = PBControl(&cpb, false);		}		if (err == noErr)		{			puts("Set serial driver handshake okay!");			do_next = 1;		}		else if (err == badUnitErr)			puts("Bad reference number error.");		else if (err == notOpenErr)			puts("Not open error.");		else if (err == unitEmptyErr)			puts("Bad reference number error.");		else if (err == controlErr)			puts("Control error.");		else			puts("Unknown error.");		/* SerClrBrk() */		cpb.ioVRefNum = 0;		cpb.ioRefNum = soutref;		cpb.csCode = 11;		if (do_next)		{			do_next = 0;			err = PBControl(&cpb, false);		}		if (err == noErr)		{			puts("Clear serial break mode okay!");			do_next = 1;		}		else if (err == badUnitErr)			puts("Bad reference number error.");		else if (err == notOpenErr)			puts("Not open error.");		else if (err == unitEmptyErr)			puts("Bad reference number error.");		else if (err == controlErr)			puts("Control error.");		else			puts("Unknown error.");		fputs("Test serial port? (y/n) ", stdout);		pchar = getchar(); putchar('\n');		if (pchar == 'y')		{			/* Write data to the serial port.  */			pb.ioVRefNum = 0;			pb.ioRefNum = soutref;			pb.ioBuffer = (char*)g_buffer;			pb.ioReqCount = 512;			pb.ioPosMode = fsFromMark;			pb.ioPosOffset = 0;			/* TODO: ioPosOffset and ioActCount set after call,			   loop for all.  */			if (do_next)			{				do_next = 0;				err = PBWrite(&pb, false);			}			if (err == noErr)			{				printf("Great write, %ld bytes.\n", pb.ioActCount);				do_next = 1;			}			else if (err == badUnitErr)				puts("Bad unit error.");			else if (err == notOpenErr)				puts("Drive isn't open error.");			else if (err == unitEmptyErr)				puts("Bad reference number error.");			else if (err == writErr)				puts("Write error.");			else				puts("Unknown error.");			/* SerStatus() */			cpb.csCode = 8;			if (do_next)			{				do_next = 0;				err = PBStatus(&cpb, false);			}			if (err == noErr)			{				ssr = (SerStaRec*)cpb.csParam;				printf("Status serial driver: "					"cumErrs = %d, rdPend = %d, wrPend = %d\n",					(int)ssr->cumErrs, (int)ssr->rdPend,					(int)ssr->wrPend);				do_next = 1;			}			else if (err == badUnitErr)				puts("Bad reference number error.");			else if (err == notOpenErr)				puts("Not open error.");			else if (err == unitEmptyErr)				puts("Bad reference number error.");			else if (err == statusErr)				puts("Status error.");			else				puts("Unknown error.");			/* RAMSDClose (sPortA); */		}	}	{		int pchar = 'n';		fputs("Perform full disk transfer WITHOUT file tags? (y/n) ",			stdout);		pchar = getchar(); putchar('\n');		if (pchar == 'y')		{			/* Loop through copying disk blocks, work with all sizes			   in bytes.  */			unsigned long td_cur = 0;			td_size <<= 9; /* td_size *= 512; */			while (td_cur < td_size)			{				OSErr err;				IOParam pb;				int pend_bufsz = 0;				/* Fill up the buffer with synchronous disk reads.  */				while (pend_bufsz < 512 * 4)				{					pb.ioVRefNum = td_dnum;					pb.ioRefNum = td_dref;					pb.ioBuffer = (char*)g_buffer + pend_bufsz;					pb.ioReqCount = (512 * 4) - pend_bufsz;					pb.ioPosMode = fsFromStart;					pb.ioPosOffset = td_cur + pend_bufsz;					err = PBRead(&pb, false);					if (err != noErr)					{						puts("Disk input error.");						if (err == badUnitErr)							puts("Bad unit error.");						else if (err == notOpenErr)							puts("Drive isn't open error.");						else if (err == unitEmptyErr)							puts("Bad reference number error.");						else if (err == readErr)							puts("Read error.");						else							puts("Unknown error.");						break;					}					pend_bufsz += pb.ioActCount;				}				if (err != noErr)					break;				td_cur += pend_bufsz;				/* Empty the buffer with synchronous serial writes.  */				pend_bufsz = 0;				while (pend_bufsz < 512 * 4)				{					pb.ioVRefNum = 0;					pb.ioRefNum = soutref;					pb.ioBuffer = (char*)g_buffer + pend_bufsz;					pb.ioReqCount = (512 * 4) - pend_bufsz;					pb.ioPosMode = fsFromMark;					pb.ioPosOffset = 0;					err = PBWrite(&pb, false);					if (err != noErr)					{						puts("Serial output error.");						if (err == badUnitErr)							puts("Bad unit error.");						else if (err == notOpenErr)							puts("Drive isn't open error.");						else if (err == unitEmptyErr)							puts("Bad reference number error.");						else if (err == writErr)							puts("Write error.");						else							puts("Unknown error.");						break;					}					pend_bufsz += pb.ioActCount;				}				if (err != noErr)					break;				/* Update status to the user.  */				putchar('.');			}			putchar('\n');			if (td_cur == td_size)			{				puts("Successful disk copy.  Enjoy!!!");			}			td_size >>= 9; /* td_size /= 512; */		}		fputs("Perform full disk + file tags transfer? (y/n) ",			stdout);		pchar = getchar(); putchar('\n');		if (pchar == 'y')		{			unsigned long td_cur = 0;			int bufsz_lim = 0;			char *ftagbase = (char*)g_buffer;			fputs("Include regular disk blocks? (y/n) ",				  stdout);			pchar = getchar(); putchar('\n');			if (pchar == 'y')			{				bufsz_lim += 512;				ftagbase += 512;			}			fputs("Include file tags? (y/n) ",				  stdout);			pchar = getchar(); putchar('\n');			if (pchar == 'y')				bufsz_lim += 12;			/* Loop through copying disk blocks, work with all sizes			   in bytes.  */			td_size <<= 9; /* td_size *= 512; */			while (td_cur < td_size)			{				OSErr err;				IOParam pb;				int pend_bufsz = 0;				/* Read one disk block + file tags.  */				pb.ioVRefNum = td_dnum;				pb.ioRefNum = td_dref;				pb.ioBuffer = (char*)g_buffer;				pb.ioReqCount = 512;				pb.ioPosMode = fsFromStart;				pb.ioPosOffset = td_cur;				err = PBRead(&pb, false);				if (err != noErr)				{					puts("Disk input error.");					if (err == badUnitErr)						puts("Bad unit error.");					else if (err == notOpenErr)						puts("Drive isn't open error.");					else if (err == unitEmptyErr)						puts("Bad reference number error.");					else if (err == readErr)						puts("Read error.");					else						puts("Unknown error.");					break;				}				if (pb.ioActCount != 512)				{					puts("Error: Failed to read exactly one block.");					break;				}				td_cur += 512;				*(long*)(ftagbase + 0) = BufTgFNum;				*(int*)(ftagbase + 4) = BufTgFFlag;				*(int*)(ftagbase + 6) = BufTgFBkNum;				*(long*)(ftagbase + 8) = BufTgDate;				/* Empty the buffer with synchronous serial writes.  */				pend_bufsz = 0;				while (pend_bufsz < bufsz_lim)				{					pb.ioVRefNum = 0;					pb.ioRefNum = soutref;					pb.ioBuffer = (char*)g_buffer + pend_bufsz;					pb.ioReqCount = bufsz_lim - pend_bufsz;					pb.ioPosMode = fsFromMark;					pb.ioPosOffset = 0;					err = PBWrite(&pb, false);					if (err != noErr)					{						puts("Serial output error.");						if (err == badUnitErr)							puts("Bad unit error.");						else if (err == notOpenErr)							puts("Drive isn't open error.");						else if (err == unitEmptyErr)							puts("Bad reference number error.");						else if (err == writErr)							puts("Write error.");						else							puts("Unknown error.");						break;					}					pend_bufsz += pb.ioActCount;				}				if (err != noErr)					break;				/* Update status to the user.  */				if ((td_cur & (2048 - 1)) == 0)					putchar('.');			}			putchar('\n');			if (td_cur == td_size)			{				puts("Successful disk + file tags copy.  Enjoy!!!");			}			td_size >>= 9; /* td_size /= 512; */		}	}	{		int pchar = 'n';		fputs("Get SCSI device information? (y/n) ",			stdout);		pchar = getchar(); putchar('\n');		if (pchar == 'y')		{			OSErr err;			PBSc1 pbsc;			unsigned char new_DeviceType;			unsigned char new_DeviceQualifier;			fputs("SCSI ID (0-6) (followed by dummy key): ", stdout);			scanf("%d", &g_scsi_id);			pbsc.scsi_id = g_scsi_id;			getchar(); /* User must type a dummy key.  */			putchar(' ');			printf("Using SCSI ID %d\n", pbsc.scsi_id);			/* PLEASE NOTE: MC68000 cannot do unaligned memory			   accesses.  */			/* Set up the command buffer with the SCSI INQUIRY			   command.  */			pbsc.scsi_id = g_scsi_id;			pbsc.cdb[0] = SC_INQUIRY; /* OPCODE */			pbsc.cdb[1] = 0; /* Reserved (6 bit), CMDDT, EVPD */			pbsc.cdb[2] = 0; /* PAGE CODE */			/* ALLOCATION LENGTH (int) */			pbsc.cdb[3] = 0;			pbsc.cdb[4] = 5;			pbsc.cdb[5] = 0; /* CONTROL */			pbsc.cdb_len = 6;			pbsc.buffer = (unsigned char*)&iq_resp;			pbsc.buffer_len = 5;			/* First get the length of the additional INQUIRY data.  */			err = sc1read(&pbsc);			if (err != noErr)			{				puts("Error executing SCSI INQUIRY command 1.");				goto noscsi;			}			if (pbsc.comp_err != noErr)			{				puts("Error completing SCSI INQUIRY command 1.");				goto noscsi;			}			if (pbsc.comp_status == SC_CHECK_CONDITION)			{				puts("Status error on SCSI INQUIRY command 1.");				goto noscsi;			}			else if (pbsc.comp_status != SC_GOOD)			{				printf("Status error %d on SCSI INQUIRY command 1.",					pbsc.comp_status);				goto noscsi;			}			/* Now read the additional INQUIRY data.  */			pbsc.cdb[3] = 0;			pbsc.cdb[4] += iq_resp.AdditionalLength;			pbsc.buffer_len += iq_resp.AdditionalLength;			if (5 + iq_resp.AdditionalLength > sizeof(MyInquiryRecord))			{				pbsc.cdb[4] = sizeof(MyInquiryRecord);				pbsc.buffer_len = sizeof(MyInquiryRecord);			}			err = sc1read(&pbsc);			if (err != noErr)			{				puts("Error executing SCSI INQUIRY command 2.");				goto noscsi;			}			if (pbsc.comp_err != noErr)			{				puts("Error completing SCSI INQUIRY command 2.");				goto noscsi;			}			if (pbsc.comp_status == SC_CHECK_CONDITION)			{				puts("Status error on SCSI INQUIRY command 2.");				goto noscsi;			}			else if (pbsc.comp_status != SC_GOOD)			{				printf("Status error %d on SCSI INQUIRY command 2.",					pbsc.comp_status);				goto noscsi;			}			/* Now do a READ CAPACITY.  */			pbsc.scsi_id = g_scsi_id;			pbsc.cdb[0] = SC_READ_CAPACITY_10; /* OPCODE */			pbsc.cdb[1] = 0; /* Reserved */			/* LOGICAL BLOCK ADDRESS (long) */			*(int*)(pbsc.cdb + 2) = (int)0;			*(int*)(pbsc.cdb + 4) = (int)0;			*(int*)(pbsc.cdb + 6) = 0; /* Reserved */			pbsc.cdb[8] = 0;  /* Reserved */			pbsc.cdb[9] = 0; /* CONTROL */			pbsc.cdb_len = 10;			pbsc.buffer = (unsigned char*)&read_cap;			pbsc.buffer_len = sizeof(MyReadCapRecord);			err = sc1read(&pbsc);			if (err != noErr)			{				puts("Error executing SCSI READ CAPACITY command.");				goto noscsi;			}			if (pbsc.comp_err != noErr)			{				puts("Error completing SCSI READ CAPACITY command.");				goto noscsi;			}			if (pbsc.comp_status == SC_CHECK_CONDITION)			{				puts("Status error on SCSI READ CAPACITY command.");				goto noscsi;			}			else if (pbsc.comp_status != SC_GOOD)			{				printf("Status error %d on SCSI READ CAPACITY command.",					pbsc.comp_status);				goto noscsi;			}			/* Now do a READ on block zero.  */			pbsc.scsi_id = g_scsi_id;			pbsc.cdb[0] = SC_READ_10; /* OPCODE */			pbsc.cdb[1] = 0; /* misc flags */			/* LOGICAL BLOCK ADDRESS (long) */			*(int*)(pbsc.cdb + 2) = (int)0;			*(int*)(pbsc.cdb + 4) = (int)0;			/* Reserved (3 bits), GROUP NUMBER? (5 bits) */			pbsc.cdb[6] = 0;			/* TRANSFER LENGTH (int, blocks) */			pbsc.cdb[7] = 0;			pbsc.cdb[8] = 1;			pbsc.cdb[9] = 0; /* CONTROL */			pbsc.cdb_len = 10;			pbsc.buffer = (unsigned char*)&ddr;			pbsc.buffer_len = sizeof(Block0);			err = sc1read(&pbsc);			if (err != noErr)			{				puts("Error executing SCSI READ command.");				goto noscsi;			}			if (pbsc.comp_err != noErr)			{				puts("Error completing SCSI READ command.");				goto noscsi;			}			if (pbsc.comp_status == SC_CHECK_CONDITION)			{				puts("Status error on SCSI READ command.");				goto noscsi;			}			else if (pbsc.comp_status != SC_GOOD)			{				printf("Status error %d on SCSI READ command.",					pbsc.comp_status);				goto noscsi;			}			{ /* Now do a READ of the first three partition map				 entries, assuming there are at least three.  */				/* N.B. We do a second SCSI read instruction so that				   we do not have to deal with blocks greater than 512				   bytes in this code.  */				unsigned i;				for (i = 0; i < 3; i++)				{					pbsc.scsi_id = g_scsi_id;					pbsc.cdb[0] = SC_READ_10; /* OPCODE */					pbsc.cdb[1] = 0; /* misc flags */					/* LOGICAL BLOCK ADDRESS (long) */					*(int*)(pbsc.cdb + 2) = (int)0;					*(int*)(pbsc.cdb + 4) = (int)(i + 1);					/* Reserved (3 bits), GROUP NUMBER? (5 bits) */					pbsc.cdb[6] = 0;					/* TRANSFER LENGTH (int, blocks) */					pbsc.cdb[7] = 0;					pbsc.cdb[8] = 1;					pbsc.cdb[9] = 0; /* CONTROL */					pbsc.cdb_len = 10;					pbsc.buffer = (unsigned char*)&pm[i];					pbsc.buffer_len = sizeof(Partition);					err = sc1read(&pbsc);					if (err != noErr)					{						puts("Error executing SCSI READ command.");						goto noscsi;					}					if (pbsc.comp_err != noErr)					{						puts("Error completing SCSI READ command.");						goto noscsi;					}					if (pbsc.comp_status == SC_CHECK_CONDITION)					{						puts("Status error on SCSI READ command.");						goto noscsi;					}					else if (pbsc.comp_status != SC_GOOD)					{						printf("Status error %d on SCSI READ command.",							   pbsc.comp_status);						goto noscsi;					}				}			}			/* Now we can print out all the information we've			   discovered.  */			new_DeviceType = iq_resp.DeviceType & (32 - 1);			new_DeviceQualifier = iq_resp.DeviceType >> 5;			switch (new_DeviceType)			{			case 0:				puts("Direct access block device.");				break;			case 1:				puts("Sequential access device (e.g. tape).");				break;			case 2:				puts("Printer device.");				break;			case 3:				puts("Processor device.");				break;			case 4:				puts("Write-once device (e.g. optical disc).");				break;			case 5:				puts("CD/DVD device.");				break;			case 6:				puts("Scanner device (obsolete).");				break;			case 7:				puts("Optical memory device (e.g. optical disc).");				break;			case 8:				puts("Medium changer device (e.g. jukebox).");				break;			case 9:				puts("Communications device (obsolete).");				break;			case 10:			case 11:				puts("Obsolete device, don't bother.");				break;			case 12:				puts("Storage array controller device (e.g. RAID).");				break;			case 13:				puts("Enclosure services device.");				break;			case 14:				puts("Simplified direct-access device (e.g. disk).");				break;			case 15:				puts("Optical card reader/writer device.");				break;			case 16:				puts("Bridge Controller Commands.");				break;			case 17:				puts("Object-based Storage Device.");				break;			case 18:				puts("Automation/Drive Interface.");				break;			case 19:			case 20:			case 21:			case 22:			case 23:			case 24:			case 25:			case 26:			case 27:			case 28:			case 29:				puts("Reserved peripheral device type.");				break;			case 30:				puts("Well known logical unit [b].");				break;			case 31:			default:				printf("Unknown or no device type 0x%02x.\n",					(int)new_DeviceType);				break;			}			switch (new_DeviceQualifier)			{			case 0:				puts("Peripheral device connected or unknown.");				break;			case 1:				puts("No connected peripheral, but supported.");				break;			case 2:				puts("Reserved peripheral qualifier.");				break;			case 3:				puts("Peripheral device not supported.");				break;			default:				printf("Vendor-specific peri. qual. 0x%x.\n",					   (int)new_DeviceQualifier);				break;			}			printf("Reserved = 0x%02x\n", iq_resp.DeviceQualifier);			printf("SCSI version = 0x%02x\n", (int)iq_resp.Version);			printf("Response data format = 0x%02x\n",				(int)iq_resp.ResponseFormat);			if (iq_resp.AdditionalLength > 0)			{				unsigned i;				fputs("VendorID: ", stdout);				for (i = 0; i < SC_VENDOR_ID_SIZE; i++)					putchar(iq_resp.VendorID[i]);				putchar('\n');				fputs("ProductID: ", stdout);				for (i = 0; i < SC_PRODUCT_ID_SIZE; i++)					putchar(iq_resp.ProductID[i]);				putchar('\n');				fputs("Revision: ", stdout);				for (i = 0; i < SC_REVISION_SIZE; i++)					putchar(iq_resp.Revision[i]);				putchar('\n');			}			/* We get the LBA of the last block, add one to get			   number of blocks.  */			printf("lbasize = %lu, blksize = %lu\n",				read_cap.last_lba + 1, read_cap.blksize);			{				int pchar = 'n';				unsigned long sw_size = 512;				fputs("Show hex dump? (y/n) ", stdout);				pchar = getchar(); putchar('\n');				if (pchar == 'y')					showhex((char*)&ddr, sw_size);			}			fputs("Display driver descriptor record? (y/n) ", stdout);			pchar = getchar(); putchar('\n');			if (pchar == 'y')			{ /* Now we parse out and print key information from the			     driver descriptor record.  */				if (ddr.sbSig == sbSIGWord)					puts("Driver descriptor signature matches.");				else					puts("Driver descriptor signature does NOT match.");				printf("Block size = %d, block count = %ld\n",					ddr.sbBlkSize, ddr.sbBlkCount);				printf("sbDevType = %d, sbDevId = %d, sbData = 0x%08lx\n",					ddr.sbDevType, ddr.sbDevId, ddr.sbData);				printf("Driver count = %d, ddBlock = 0x%08lx, "					"ddSize = %d, ddType = %d\n",					ddr.sbDrvrCount, ddr.ddBlock, ddr.ddSize, ddr.ddType);			}			if (read_cap.blksize != ddr.sbBlkSize)			{				puts("Error: SCSI block size does not match driver "					"descriptor block size.");				goto noscsi;			}			if (read_cap.last_lba + 1 != ddr.sbBlkCount)			{				puts("Warning: SCSI block count does not match driver "					"descriptor block count.");			}			fputs("Display partition map? (y/n) ", stdout);			pchar = getchar(); putchar('\n');			if (pchar == 'y')			{ /* Now we parse out and print key information from				 partition map entries.  */				unsigned i;				for (i = 0; i < 3; i++)				{					if (pm[i].pmSig == pMapSIG)						printf("Partition map %d signature matches. ", i);					else					{						printf("Partition map %d signature "							"does NOT match.\n", i);						continue;					}					printf("pmSigPad = %d, pmMapBlkCnt = %ld\n",						pm[i].pmSigPad, pm[i].pmMapBlkCnt);					printf("pmPyPartStart = 0x%08lx, pmPartBlkCnt = %ld\n",						pm[i].pmPyPartStart, pm[i].pmPartBlkCnt);					{						unsigned j;						fputs("pmPartName: ", stdout);						for (j = 0; j < 32; j++)							putchar(pm[i].pmPartName[j]);						putchar('\n');						fputs("pmParType: ", stdout);						for (j = 0; j < 32; j++)							putchar(pm[i].pmParType[j]);						putchar('\n');					}					printf("pmLgDataStart = 0x%08lx, pmDataCnt = %ld\n",						pm[i].pmLgDataStart, pm[i].pmDataCnt);					printf("pmPartStatus = 0x%08lx, pmLgBootStart = 0x%08lx, "						"pmBootSize = %ld\n",						pm[i].pmPartStatus, pm[i].pmLgBootStart,						pm[i].pmBootSize);					printf("pmBootAddr = 0x%08lx, pmBootAddr2 = 0x%08lx\n"						"pmBootEntry = 0x%08lx, pmBootEntry2 = 0x%08lx\n",						pm[i].pmBootAddr, pm[i].pmBootAddr2,						pm[i].pmBootEntry, pm[i].pmBootEntry2);					printf("pmBootCksum = 0x%08lx\n", pm[i].pmBootCksum);					{ /* Now print the pmProcessor field, if					     applicable.  Classic Macintoshes will						 show nothing but garbage.  */						unsigned i;						char *pmProcessor = (char*)&pm[i] + 120;						fputs("pmProcessor: ", stdout);						for (i = 0; i < 16; i++)							putchar(pmProcessor[i]);						putchar('\n');					}				}			}			sc_init = 1;		noscsi:			;		}	}	if (sc_init)	{		int pchar = 'n';		fputs("Perform full disk + system bytes transfer? (y/n) ",			stdout);		pchar = getchar(); putchar('\n');		if (pchar == 'y' && read_cap.blksize > 532)		{			puts("Error: Only <= 532-byte block SCSI disks are "				"currently supported.");		}		else if (pchar == 'y')		{			unsigned long sc_size = read_cap.last_lba + 1;			int blksize = read_cap.blksize;			/* N.B. We assume the number of disk blocks is divisible			   by 4.  */			/* Loop through copying disk blocks, work with all sizes			   in bytes.  */			unsigned long sc_cur = 0;			if (blksize > 512)			{				int pchar = 'n';				printf("Block size %d > 512.  Proceed? (y/n) ",					blksize);				pchar = getchar(); putchar('\n');				if (pchar != 'y')					goto noscimg;			}			while (sc_cur < sc_size)			{				OSErr err;				PBSc1 pbsc;				IOParam pb;				int pend_bufsz = 0, buflim = 0;				/* Fill up the buffer with synchronous SCSI disk reads.  */				pbsc.scsi_id = g_scsi_id;				pbsc.cdb[0] = SC_READ_10; /* OPCODE */				pbsc.cdb[1] = 0; /* misc flags */				/* LOGICAL BLOCK ADDRESS (long) */				*(int*)(pbsc.cdb + 2) = (int)(sc_cur >> 16);				*(int*)(pbsc.cdb + 4) = (int)sc_cur;				/* Reserved (3 bits), GROUP NUMBER? (5 bits) */				pbsc.cdb[6] = 0;				/* TRANSFER LENGTH (int, blocks) */				pbsc.cdb[7] = 0;				pbsc.cdb[8] = 4;				pbsc.cdb[9] = 0; /* CONTROL */				pbsc.cdb_len = 10;				pbsc.buffer = (unsigned char*)g_buffer;				pbsc.buffer_len = blksize * 4;				err = sc1read(&pbsc);				if (err != noErr)				{					puts("Error executing SCSI READ command.");					break;				}				if (pbsc.comp_err != noErr)				{					puts("Error completing SCSI READ command.");					break;				}				if (pbsc.comp_status == SC_CHECK_CONDITION)				{					puts("Status error on SCSI READ command.");					break;				}				else if (pbsc.comp_status != SC_GOOD)				{					printf("Status error %d on SCSI READ command.",						   pbsc.comp_status);					break;				}				buflim = pend_bufsz = blksize * 4;				sc_cur += 4;				/* Empty the buffer with synchronous serial writes.  */				pend_bufsz = 0;				while (pend_bufsz < buflim)				{					pb.ioVRefNum = 0;					pb.ioRefNum = soutref;					pb.ioBuffer = (char*)g_buffer + pend_bufsz;					pb.ioReqCount = buflim - pend_bufsz;					pb.ioPosMode = fsFromMark;					pb.ioPosOffset = 0;					err = PBWrite(&pb, false);					if (err != noErr)					{						puts("Serial output error.");						if (err == badUnitErr)							puts("Bad unit error.");						else if (err == notOpenErr)							puts("Drive isn't open error.");						else if (err == unitEmptyErr)							puts("Bad reference number error.");						else if (err == writErr)							puts("Write error.");						else							puts("Unknown error.");						break;					}					pend_bufsz += pb.ioActCount;				}				if (err != noErr)					break;				/* Update status to the user.  */				putchar('.');			}			putchar('\n');			if (sc_cur == sc_size)			{				puts("Successful disk copy.  Enjoy!!!");			}		}	noscimg:		;	}}